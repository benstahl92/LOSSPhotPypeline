import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

class plotLC:
    '''
    Light curve plotting for LOSSPhotPypeline outputs
    '''

    def __init__(self, lc = None, lc_raw = None, lc_file = None, tref = 'min', filters = ('B','V','R','I','CLEAR'), 
                 offset_scale = 1, style = 'white', context = 'notebook', name = None, photmethod = None):
        '''
        instantiation instructions

        Parameters
        ----------
        lc : pandas.DataFrame, optional, default: None
            internal representation of light curve
            must have columns: MJD, B, EB, V, EV, R, ER, I, EI, CLEAR, ECLEAR
        lc : pandas.DataFrame, optional, default: None
            dataframe in "raw" light curve format
        lc_file : str, optional, default: None
            name of file containing light curve to plot
        tref : int or float, optional, default: 'min'
            time to reference all others to
        filters : iterable, optional, default: ('B','V','R','I','CLEAR')
            photometric passbands to plot
        style : str, optional, default: 'white'
            seaborn plot style to use
        context : str, optional, default: 'notebook'
            seaborn context to use
        '''

        self.lc = lc
        self.raw = lc_raw
        self.lc_file = lc_file
        self.tref = tref
        self.filters = filters
        self.offset_scale = offset_scale
        self.style = style
        self.context = context
        self.name = name
        self.photmethod = photmethod

        self.tset = False

        filters = [filt.upper() for filt in filters]
        if set(filters).issubset(('B','V','R','I','CLEAR')) is False:
            print('provided filter set is not supported, exiting')
            return

        if (self.lc is None) and (self.lc_raw is None) and (self.lc_file is not None):
            self.load_lc(self.lc_file)
            self._set_t()

    def _color(self, filt):
        '''returns color to plot for given filter'''
        if filt == 'B':
            return 'blue'
        elif filt == 'V':
            return 'green'
        elif filt == 'R':
            return 'red'
        elif filt == 'I':
            return 'darkred'
        else:
            return 'black'

    def _offset(self, filt):
        '''returns magnitude offset for given filter'''
        if filt == 'B':
            return 2*self.offset_scale
        elif filt == 'V':
            return 1*self.offset_scale
        elif filt == 'R':
            return 0*self.offset_scale
        elif filt == 'I':
            return -1*self.offset_scale
        else:
            return 0*self.offset_scale

    def _set_t(self):
        '''set time relative to reference'''
        if self.tref == 'min':
            self.tref = lc['MJD'].min()
        if self.lc is not None:
            self.lc['t_ref'] = self.lc['MJD'] - self.tref
            self.tset = True
        else:
            print('no lc to set t_ref for, exiting')
            return

    def _transform_raw(self):
        '''transforms dataframe of light curve in raw format to internal format'''
        df = self.raw
        df['err'] = (df['+emag'] - df['-emag']) / 2
        self.lc = pd.concat([df[df['filter'].str.upper() == filt][['mjd', 'mag','err']].set_axis(['MJD', filt, 'E' + filt], axis = 'columns', inplace = False),
                             for filt in self.filters], sort = False)

    def _load_raw(self, lc_file):
        '''loads "raw" light curves generated by LOSSPhotPypeline.pipeline.LPP'''
        if 'raw' not in lc_file:
            print('{} must have "raw" in its name, exiting.'.format(lc_file))
            return
        df = pd.read_csv(lc_file, delim_whitespace = True, comment = ';',
                         names = ('mjd', 'etburst', 'mag', '-emag', '+emag', 'limmag', 'filter', 'imagename'))
        self.raw = df # is a copy needed here?
        self._transform_raw()

    def _load_standard(self, lc_file):
        '''loads "standard" light curves generated by LOSSPhotPypeline.pipeline.LPP'''
        if 'standard' not in lc_file:
            print('{} must have "standard" in its name, exiting.'.format(lc_file))
            return
        self.lc = pd.read_csv(lc_file, delim_whitespace = True, usecols = (1,3,4,5,6,7,8,9,10,11,12))

    def load_lc(self, lc_file):
        '''
        Interprets the supplied light curve file and loads appropriately.

        Parameters
        ----------
        lc_file : str
            name of file containing light curve
            should either be a "raw" or "standard" file for LOSSPhotPypeline
        '''

        if 'raw' in lc_file:
            self._load_raw(lc_file)
        elif 'standard' in lc_file:
            self._load_standard(lc_file)
        else:
            print('{} is an unrecognized light curve format, exiting')
            return

    def plot_lc(self, style = None, context = None, return_fig = False):
        '''
        Plots light curve.

        Parameters
        ----------
        style : str, optional, default: 'white'
            seaborn plot style to use
        context : str, optional, default: 'notebook'
            seaborn context to use
        return_fig : bool, optional, default : False
            return figure and axes if True
        '''

        # set plot attributes
        if style is None:
            style = self.style
        if context is None:
            context = self.context
        sns.set_style(style)
        sns.set_context(context)

        if self.tset is False:
            self._set_t()

        # make plot
        fig, ax = plt.subplots(1,1)
        for filt in filters:
            tmp = self.lc[~self.lc[filt].isnan()]
            ax.errorbar(tmp['t_rel'], tmp[filt] + self._offset(filt), yerr = tmp['E' + filt], fmt = '.',
                        c = self._color(filt), label = '{} + {}'.format(filt, self._offset(filt)))
        ax.legend()
        ax.invert_yaxis()
        ax.set_xlabel('Time (MJD - {:.1f})'.format(self.tref))
        ax.set_ylabel('Mag')
        if self.name is not None:
            title_msg = self.name
            if self.photmethod is not None:
                title_msg += ' ({})'.format(self.photmethod)
        if return_fig:
            return fig, ax
        else:
            plt.savefig('{}.ps'.format(self.lc_file.split('.dat')[0]), bbox_inches = 'tight')
